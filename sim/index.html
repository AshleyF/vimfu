<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>VimFu Simulator</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    color: #d4d4d4;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    height: 100dvh;
    overflow: hidden;
  }

  /* ── Header row ── */
  .header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.5rem 0;
    flex-shrink: 0;
  }
  h1 {
    font-size: 1.4rem;
    color: #82aaff;
  }

  .mode-badge {
    display: inline-block;
    padding: 2px 10px;
    border-radius: 4px;
    font-family: 'Cascadia Mono', Consolas, monospace;
    font-size: 0.85rem;
    font-weight: 700;
    transition: background 0.15s, color 0.15s;
  }
  .mode-badge.shell   { background: #89ddff; color: #000; }
  .mode-badge.normal   { background: #82aaff; color: #000; }
  .mode-badge.insert   { background: #c3e88d; color: #000; }
  .mode-badge.visual,
  .mode-badge.visual_line { background: #c792ea; color: #000; }
  .mode-badge.replace  { background: #f78c6c; color: #000; }
  .mode-badge.command  { background: #3c3c3c; color: #d4d4d4; }

  /* ── Terminal area (fills remaining space) ── */
  .terminal-area {
    flex: 1 1 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    position: relative;
  }

  .loading-overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 1rem;
    z-index: 1;
    transition: opacity 0.3s;
  }
  .loading-overlay.hidden { opacity: 0; pointer-events: none; }

  .loading-spinner {
    width: 28px;
    height: 28px;
    border: 3px solid #333;
    border-top-color: #82aaff;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  .loading-text {
    font-family: 'Cascadia Mono', Consolas, monospace;
    font-size: 0.85rem;
    color: #555;
  }

  #terminal {
    cursor: text;
    outline: none;
    opacity: 0;
    transition: opacity 0.3s;
  }
  #terminal.ready { opacity: 1; }

  /* ── Virtual keyboard toggle ── */
  .vkb-toggle {
    position: fixed;
    bottom: 12px;
    right: 12px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 2px solid #555;
    background: #2a2a40;
    color: #82aaff;
    font-size: 22px;
    cursor: pointer;
    z-index: 100;
    display: none; /* shown by JS */
    align-items: center;
    justify-content: center;
    line-height: 1;
    -webkit-tap-highlight-color: transparent;
  }
  .vkb-toggle:active { background: #3a3a55; }

  /* ── Virtual keyboard ── */
  .vkb {
    display: none;
    flex-direction: column;
    gap: 6px;
    padding: 6px 3px;
    width: 100%;
    background: #0d0d1a;
    flex-shrink: 0;
    -webkit-user-select: none;
    user-select: none;
    touch-action: manipulation;
  }
  .vkb.visible { display: flex; }

  .vkb-row {
    display: flex;
    gap: 5px;
    justify-content: center;
  }

  .vkb-key {
    flex: 1 1 0;
    height: 42px;
    border-radius: 5px;
    background: #3a3a4a;
    color: #fff;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 18px;
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.08s;
    overflow: hidden;
    white-space: nowrap;
  }
  .vkb-key:active, .vkb-key.pressed { background: #606080; }

  /* Wider special keys */
  .vkb-key.w15 { flex: 1.5 1 0; }
  .vkb-key.space { flex: 4 1 0; }

  /* Function/special keys (darker, smaller text) */
  .vkb-key.fn {
    background: #2a2a3a;
    font-size: 13px;
    font-weight: 600;
  }
  .vkb-key.fn:active, .vkb-key.fn.pressed { background: #606080; }

  /* Modifier active state */
  .vkb-key.mod-active {
    background: #82aaff;
    color: #000;
  }
  .vkb-key.mod-active:active, .vkb-key.mod-active.pressed { background: #6688cc; }

  /* Shift state label swap */
  .vkb-key .lbl-shift { display: none; }
  .vkb.shifted .vkb-key .lbl-normal { display: none; }
  .vkb.shifted .vkb-key .lbl-shift { display: inline; }

  @media (min-width: 920px) {
    body { background: #1a1a2e; justify-content: center; padding: 1rem; }
  }
  @media (max-width: 919px) {
    body { justify-content: flex-start; padding: 0; }

    .header { padding: 4px 0; }
    h1 { font-size: 1.1rem; }
    .mode-badge { font-size: 0.75rem; padding: 1px 8px; }
  }

</style>
</head>
<body>

<div class="header" id="header">
  <h1>VimFu</h1>
  <div id="mode-badge" class="mode-badge shell">SHELL</div>
</div>

<div class="terminal-area" id="terminal-area">
  <div class="loading-overlay" id="loading">
    <div class="loading-spinner"></div>
    <div class="loading-text">Loading terminal…</div>
  </div>
  <canvas id="terminal" tabindex="0"></canvas>
</div>

<button class="vkb-toggle" id="vkb-toggle" aria-label="Toggle keyboard">⌨</button>

<div class="vkb" id="vkb">
  <div class="vkb-row" id="vkb-row-1"></div>
  <div class="vkb-row" id="vkb-row-2"></div>
  <div class="vkb-row" id="vkb-row-3"></div>
  <div class="vkb-row" id="vkb-row-4"></div>
  <div class="vkb-row" id="vkb-row-5"></div>
</div>

<script type="module">
import { SessionManager }    from './src/session.js';
import { SessionController } from './src/session_controller.js';
import { Renderer }          from './src/renderer.js';
import { SAMPLE_PYTHON }     from './src/samples.js';

const FONT_SIZE = 18;
const MIN_ROWS = 10;
const MIN_COLS = 20;
const MAX_COLS = 80; // cap on wide screens
const MAX_ROWS = 40;

// ── Renderer (created first to measure character cell size) ──
const canvas = document.getElementById('terminal');
const renderer = new Renderer(canvas, { fontSize: FONT_SIZE });
const { charW, charH, padding: canvasPad } = renderer;

// ── Compute initial terminal dimensions from available space ──
const header   = document.getElementById('header');
const termArea = document.getElementById('terminal-area');
const vkb      = document.getElementById('vkb');

function computeGridSize() {
  const availW = termArea.clientWidth;
  const availH = termArea.clientHeight;
  const cols = Math.max(MIN_COLS, Math.min(MAX_COLS, Math.floor((availW - canvasPad * 2) / charW)));
  const rows = Math.max(MIN_ROWS, Math.min(MAX_ROWS, Math.floor((availH - canvasPad * 2) / charH)));
  return { rows, cols };
}

const initSize = computeGridSize();

const session = new SessionManager({
  rows: initSize.rows,
  cols: initSize.cols,
  themeName: 'monokai',
  persist: true,
});

// Seed filesystem with sample files on first visit
if (session.fs.fileCount === 0) {
  session.fs.write('notes.txt', [
    'Shopping list:',
    '  - milk',
    '  - eggs',
    '  - bread',
  ].join('\n'));
}

// Always ensure demo.py exists (even for returning users)
if (!session.fs.exists(SAMPLE_PYTHON.filename)) {
  session.fs.write(SAMPLE_PYTHON.filename, SAMPLE_PYTHON.content);
}

// Always ensure welcome.md exists (even for returning users)
if (!session.fs.exists('welcome.md')) {
  session.fs.write('welcome.md', [
    '# Welcome to VimFu',
    '',
    'Learn Vim — zero to fluency.',
    '',
    '## Quick Start',
    '',
    '- Press `i` for Insert mode',
    '- Press `Esc` for Normal mode',
    '- Type `:w` to save',
    '- Type `:q` to quit',
    '',
    '## Explore',
    '',
    'Try editing this file!',
    '',
    '- `:wq` — save and quit',
    '- `:q!` — quit without saving',
    '',
    '> Tip: `help` at the shell',
  ].join('\n'));
}

// ── Mode badge ──
const modeBadge = document.getElementById('mode-badge');
const MODE_COLORS = {
  SHELL:       'shell',
  NORMAL:      'normal',
  INSERT:      'insert',
  VISUAL:      'visual',
  'VISUAL LINE': 'visual_line',
  REPLACE:     'replace',
  COMMAND:     'command',
};

function onUpdate(frame) {
  renderer.draw(frame);
  const label = session.getModeLabel();
  modeBadge.textContent = label;
  modeBadge.className = 'mode-badge ' + (MODE_COLORS[label] || 'shell');
}

// ── Controller ──
const ctrl = new SessionController(session, onUpdate);
ctrl.attach(canvas);

// Initial render
onUpdate(session.renderFrame());
canvas.classList.add('ready');
document.getElementById('loading').classList.add('hidden');
canvas.focus();

// ── Boot sequence: launch nvim immediately ──
if (session.mode === 'shell') {
  session.shell.showWelcome('boot');
  session.shell._inputLine = 'nvim welcome.md';
  session.shell._cursorPos = 15;
  session.shell.feedKey('Enter');
  onUpdate(session.renderFrame());
}

// ── Dynamic terminal resizing ──
let resizeRAF = 0;
function handleResize() {
  cancelAnimationFrame(resizeRAF);
  resizeRAF = requestAnimationFrame(() => {
    const { rows, cols } = computeGridSize();
    session.resize(rows, cols);
    onUpdate(session.renderFrame());
  });
}
window.addEventListener('resize', handleResize);

// ── Virtual Keyboard ──
const vkbToggle = document.getElementById('vkb-toggle');

// ── Two-page keyboard: ABC (with numbers) and 123 (all symbols + arrows) ──
// Key: string char (auto-expands) or [label, shifted, class, keySend, shiftedSend]
const PAGES = {
  abc: [
    // Number row: shift shows standard shifted-digit symbols
    [['1','!'], ['2','@'], ['3','#'], ['4','$'], ['5','%'],
     ['6','^'], ['7','&'], ['8','*'], ['9','('], ['0',')']],
    ['q','w','e','r','t','y','u','i','o','p'],
    ['a','s','d','f','g','h','j','k','l'],
    [['⇧','⇧','w15 fn','_shift','_shift'],
     'z','x','c','v','b','n','m',
     ['⌫','⌫','w15 fn','Backspace','Backspace']],
    [['#+=','#+=','w15 fn','_page_num','_page_num'],
     ['Esc','Esc','fn','Escape','Escape'],
     ['Ctrl','Ctrl','fn','_ctrl','_ctrl'],
     ['','','space',' ',' '],
     '.',
     ['⏎','⏎','w15 fn','Enter','Enter']],
  ],
  num: [
    // Row 1: shifted-digit symbols (same positions as ABC number row)
    ['!','@','#','$','%','^','&','*','(', ')'],
    // Row 2: common Vim/programming symbols
    ['`','~','-','_','=','+','\\','|','/','?'],
    // Row 3: brackets and quotes
    ['[',']','{','}','<','>',';',':','\'','"'],
    // Row 4: Tab, arrows, delete
    [['Tab','Tab','fn','Tab','Tab'],
     ',',
     ['←','←','fn','ArrowLeft','ArrowLeft'],
     ['↓','↓','fn','ArrowDown','ArrowDown'],
     ['↑','↑','fn','ArrowUp','ArrowUp'],
     ['→','→','fn','ArrowRight','ArrowRight'],
     ['⌫','⌫','fn','Backspace','Backspace']],
    // Row 5: controls
    [['ABC','ABC','w15 fn','_page_abc','_page_abc'],
     ['Esc','Esc','fn','Escape','Escape'],
     ['Ctrl','Ctrl','fn','_ctrl','_ctrl'],
     ['','','space',' ',' '],
     ['⏎','⏎','w15 fn','Enter','Enter']],
  ],
};

const ROW_IDS = ['vkb-row-1','vkb-row-2','vkb-row-3','vkb-row-4','vkb-row-5'];

let currentPage = 'abc';
let shiftActive = false;
let ctrlActive = false;
let shiftLock = false;
let ctrlLock = false;

function expandKey(k) {
  if (typeof k === 'string') {
    return [k, k.toUpperCase(), '', k, k.toUpperCase()];
  }
  return [k[0], k[1]||k[0], k[2]||'', k[3]||k[0], k[4]||k[1]||k[0]];
}

function buildVKBPage(page) {
  currentPage = page;
  const pageDef = PAGES[page];
  ROW_IDS.forEach((id, i) => {
    const el = document.getElementById(id);
    el.innerHTML = '';
    if (i >= pageDef.length) return;
    pageDef[i].forEach(keyDef => {
      const [normal, shifted, cls, keySend, shiftedKeySend] = expandKey(keyDef);
      const btn = document.createElement('div');
      btn.className = 'vkb-key' + (cls ? ' ' + cls : '');
      if (normal.length === 1 && normal !== shifted) {
        btn.innerHTML = `<span class="lbl-normal">${esc(normal)}</span><span class="lbl-shift">${esc(shifted)}</span>`;
      } else {
        btn.textContent = normal;
      }
      btn.dataset.key = keySend;
      btn.dataset.shiftKey = shiftedKeySend;
      el.appendChild(btn);
    });
  });
  updateModButtons();
}

function esc(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

function sendVKBKey(key) {
  if (key === '_shift') return; // handled separately
  if (key === '_ctrl') return;

  let finalKey = key;
  if (ctrlActive && key.length === 1 && /[a-zA-Z]/.test(key)) {
    finalKey = 'Ctrl-' + key.toUpperCase();
  }
  ctrl.handleKey(finalKey);

  // Release non-locked modifiers after a keypress
  if (shiftActive && !shiftLock) {
    shiftActive = false;
    vkb.classList.remove('shifted');
    updateModButtons();
  }
  if (ctrlActive && !ctrlLock) {
    ctrlActive = false;
    updateModButtons();
  }
}

function updateModButtons() {
  vkb.querySelectorAll('.vkb-key').forEach(btn => {
    if (btn.dataset.key === '_shift') {
      btn.classList.toggle('mod-active', shiftActive);
    }
    if (btn.dataset.key === '_ctrl') {
      btn.classList.toggle('mod-active', ctrlActive);
    }
  });
}

// Double-tap to lock, single tap to toggle
let lastShiftTap = 0;
let lastCtrlTap = 0;

function handleModTap(mod) {
  const now = Date.now();
  if (mod === '_shift') {
    if (now - lastShiftTap < 350) {
      // Double-tap: lock
      shiftLock = !shiftLock;
      shiftActive = shiftLock;
    } else {
      if (shiftLock) {
        shiftLock = false;
        shiftActive = false;
      } else {
        shiftActive = !shiftActive;
      }
    }
    lastShiftTap = now;
    vkb.classList.toggle('shifted', shiftActive);
    updateModButtons();
  } else if (mod === '_ctrl') {
    if (now - lastCtrlTap < 350) {
      ctrlLock = !ctrlLock;
      ctrlActive = ctrlLock;
    } else {
      if (ctrlLock) {
        ctrlLock = false;
        ctrlActive = false;
      } else {
        ctrlActive = !ctrlActive;
      }
    }
    lastCtrlTap = now;
    updateModButtons();
  }
}

buildVKBPage('abc');

// Event delegation on the keyboard container
vkb.addEventListener('pointerdown', e => {
  const btn = e.target.closest('.vkb-key');
  if (!btn) return;
  e.preventDefault();
  btn.classList.add('pressed');

  const baseKey = btn.dataset.key;
  if (baseKey === '_shift' || baseKey === '_ctrl') {
    handleModTap(baseKey);
    return;
  }
  if (baseKey.startsWith('_page_')) {
    buildVKBPage(baseKey.slice(6));
    return;
  }

  const key = shiftActive ? btn.dataset.shiftKey : baseKey;
  sendVKBKey(key);
});

vkb.addEventListener('pointerup', e => {
  const btn = e.target.closest('.vkb-key');
  if (btn) btn.classList.remove('pressed');
});

vkb.addEventListener('pointerleave', e => {
  const btn = e.target.closest('.vkb-key');
  if (btn) btn.classList.remove('pressed');
});

// Prevent any context menus or text selection on the keyboard
vkb.addEventListener('contextmenu', e => e.preventDefault());

// ── Touch/mobile detection ──
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

// Suppress native soft keyboard by using a hidden input trick on touch devices
if (isTouchDevice) {
  canvas.style.cursor = 'default';
  // Prevent native keyboard from popping up when tapping the canvas
  // Tap on canvas or the black bezel area toggles VKB
  const hideFn = e => {
    e.preventDefault();
    canvas.focus({ preventScroll: true });
    setVKBVisible(!vkb.classList.contains('visible'));
  };
  canvas.addEventListener('touchstart', hideFn);
  document.getElementById('terminal-area').addEventListener('touchstart', e => {
    if (e.target === canvas) return; // already handled above
    hideFn(e);
  });
  // Add inputMode none to suppress soft keyboard even when focused
  canvas.setAttribute('inputmode', 'none');
}

// ── VKB visibility with localStorage persistence ──
const VKB_KEY = 'vimfu-vkb';
const savedVKB = localStorage.getItem(VKB_KEY);

function setVKBVisible(show, persist = true) {
  canvas.style.visibility = 'hidden';          // hide stale frame
  vkb.classList.toggle('visible', show);
  vkbToggle.textContent = show ? '✕' : '⌨';
  if (persist) localStorage.setItem(VKB_KEY, show ? '1' : '0');
  // Resize synchronously in one rAF so there's no stale-size flash
  cancelAnimationFrame(resizeRAF);
  resizeRAF = requestAnimationFrame(() => {
    const { rows, cols } = computeGridSize();
    session.resize(rows, cols);
    onUpdate(session.renderFrame());
    canvas.style.visibility = '';                // reveal new frame
  });
}

vkbToggle.addEventListener('click', () => {
  setVKBVisible(!vkb.classList.contains('visible'));
});

if (isTouchDevice) {
  // Move toggle button into the header bar
  const header = document.querySelector('.header');
  vkbToggle.style.display = 'flex';
  vkbToggle.style.position = 'static';
  vkbToggle.style.width = '32px';
  vkbToggle.style.height = '32px';
  vkbToggle.style.fontSize = '18px';
  header.appendChild(vkbToggle);

  // Use saved preference, otherwise default to visible
  const showVKB = savedVKB !== null ? savedVKB === '1' : true;
  setVKBVisible(showVKB, false);

  // Auto-detect hardware keyboard: first physical keydown hides VKB
  if (savedVKB === null) {
    const detectHardwareKB = () => {
      setVKBVisible(false); // persists to localStorage
      window.removeEventListener('keydown', detectHardwareKB);
    };
    window.addEventListener('keydown', detectHardwareKB);
  }
} else {
  // Desktop: no VKB needed
}

</script>

</body>
</html>
