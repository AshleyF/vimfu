/**
 * VimFu Simulator – Tmux Screen Tests
 *
 * Compares rendered screen frames from tmux scenarios against
 * ground truth snapshots, ensuring pixel-perfect screen output for the
 * full tmux integration including pane layout, borders, status bar,
 * overlays, and colors.
 *
 * This mirrors the test_session_screen.js approach:
 *   1. Replay each scenario through SessionManager (launch tmux, split, etc.)
 *   2. Render a frame
 *   3. Compare text, cursor, and color runs against ground truth
 *
 * Ground truth is generated by: node test/gen_tmux_ground_truth.js
 *
 * Usage:
 *   node test/test_tmux_screen.js                  # run all cases
 *   node test/test_tmux_screen.js --case tmux_fresh_launch
 *   node test/test_tmux_screen.js --no-color       # skip color checks
 */

import { readFileSync, existsSync } from 'fs';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';
import { SessionManager } from '../src/session.js';

const __dirname = dirname(fileURLToPath(import.meta.url));
const GT_PATH = resolve(__dirname, 'tmux_ground_truth.json');

// ── Parse args ──
const args = process.argv.slice(2);
let filterCase = null;
let skipColors = false;
for (let i = 0; i < args.length; i++) {
  if (args[i] === '--case' && args[i + 1]) filterCase = args[++i];
  else if (args[i] === '--no-color') skipColors = true;
}

// ── Load ground truth ──
if (!existsSync(GT_PATH)) {
  console.error('Ground truth not found! Run: node test/gen_tmux_ground_truth.js');
  process.exit(1);
}
const groundTruth = JSON.parse(readFileSync(GT_PATH, 'utf-8'));

// ── Helpers ──
const ROWS = 20;
const COLS = 40;

function newSession(opts = {}) {
  return new SessionManager({
    rows: ROWS, cols: COLS, persist: false, ...opts,
  });
}

function feedString(s, str) {
  for (const ch of str) s.feedKey(ch);
}

/**
 * Freeze the live clock/date on the tmux status bar so it matches
 * the ground truth (which was frozen at generation time).
 */
function freezeStatusBarTime(frame) {
  const lastRow = frame.lines.length - 1;
  if (lastRow < 0) return;
  let text = frame.lines[lastRow].text;
  text = text.replace(/\d{2}:\d{2}/, '00:00');
  text = text.replace(/\d{1,2}-[A-Z][a-z]{2}-\d{2}/, '01-Jan-26');
  frame.lines[lastRow].text = text;
}

function diffLines(expected, actual) {
  const diffs = [];
  const maxLen = Math.max(expected.length, actual.length);
  for (let i = 0; i < maxLen; i++) {
    const e = expected[i] ?? '<missing>';
    const a = actual[i] ?? '<missing>';
    if (e !== a) {
      diffs.push({ row: i, expected: JSON.stringify(e), actual: JSON.stringify(a) });
    }
  }
  return diffs;
}

function diffRuns(gtFrame, simFrame) {
  const diffs = [];
  const numRows = Math.min(gtFrame.lines.length, simFrame.lines.length);
  for (let i = 0; i < numRows; i++) {
    const gtRuns = gtFrame.lines[i].runs;
    const simRuns = simFrame.lines[i].runs;
    const gtStr = gtRuns.map(r => `${r.n}:${r.fg}/${r.bg}`).join(' ');
    const simStr = simRuns.map(r => `${r.n}:${r.fg}/${r.bg}`).join(' ');
    if (gtStr !== simStr) {
      diffs.push({ row: i, expected: gtStr, actual: simStr });
    }
  }
  return diffs;
}

// ── Scenario replay definitions ──
// Each scenario returns the SessionManager state at the point to snapshot.
// The function receives a pre-constructed session and mutates it.
// For scenarios that need non-default dimensions, we return a custom session.
const scenarios = {

  // ─── Basic tmux launch ───

  tmux_fresh_launch(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
  },

  tmux_type_in_shell(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    feedString(s, 'echo hello');
    s.feedKey('Enter');
  },

  tmux_ls_in_pane(s) {
    s.fs.write('foo.txt', 'foo');
    s.fs.write('bar.txt', 'bar');
    feedString(s, 'tmux');
    s.feedKey('Enter');
    feedString(s, 'ls');
    s.feedKey('Enter');
  },

  // ─── Vim inside tmux ───

  tmux_vim_launch(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    feedString(s, 'vim test.txt');
    s.feedKey('Enter');
  },

  tmux_vim_with_content(s) {
    s.fs.write('hello.txt', 'Hello World\nSecond line\nThird line');
    feedString(s, 'tmux');
    s.feedKey('Enter');
    feedString(s, 'vim hello.txt');
    s.feedKey('Enter');
  },

  tmux_vim_insert_and_quit(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    feedString(s, 'vim test.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'typed in tmux');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'wq');
    s.feedKey('Enter');
  },

  // ─── Vertical split ───

  tmux_vsplit(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
  },

  tmux_vsplit_type_left(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    feedString(s, 'echo LEFT');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
    s.feedKey('Ctrl-B');
    s.feedKey('ArrowLeft');
  },

  tmux_vsplit_type_both(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    feedString(s, 'echo LEFT');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
    feedString(s, 'echo RIGHT');
    s.feedKey('Enter');
  },

  // ─── Horizontal split ───

  tmux_hsplit(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('"');
  },

  tmux_hsplit_type_both(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    feedString(s, 'echo TOP');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('"');
    feedString(s, 'echo BOTTOM');
    s.feedKey('Enter');
  },

  // ─── Mixed splits ───

  tmux_three_panes(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
    s.feedKey('Ctrl-B');
    s.feedKey('"');
  },

  // tmux_four_panes uses custom dimensions — handled specially below

  tmux_vim_and_shell_split(s) {
    s.fs.write('code.txt', 'line 1\nline 2\nline 3');
    feedString(s, 'tmux');
    s.feedKey('Enter');
    feedString(s, 'vim code.txt');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
  },

  // ─── Pane navigation ───

  tmux_navigate_left(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    feedString(s, 'echo PANE0');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
    feedString(s, 'echo PANE1');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('ArrowLeft');
  },

  tmux_navigate_cycle_o(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
    s.feedKey('Ctrl-B');
    s.feedKey('o');
    s.feedKey('Ctrl-B');
    s.feedKey('o');
  },

  // ─── Status bar variations ───

  tmux_status_bar_single_window(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
  },

  tmux_status_bar_two_windows(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('c');
  },

  tmux_status_bar_three_windows(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('c');
    s.feedKey('Ctrl-B');
    s.feedKey('c');
    s.feedKey('Ctrl-B');
    s.feedKey('1');
  },

  tmux_status_bar_renamed(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey(',');
    s.feedKey('Ctrl-U');
    feedString(s, 'myterm');
    s.feedKey('Enter');
  },

  tmux_status_bar_zoomed(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
    s.feedKey('Ctrl-B');
    s.feedKey('z');
  },

  // ─── Command prompt ───

  tmux_command_prompt_empty(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey(':');
  },

  tmux_command_prompt_typed(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey(':');
    feedString(s, 'split-window');
  },

  // ─── Rename prompt ───

  tmux_rename_prompt(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey(',');
  },

  tmux_rename_prompt_typed(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey(',');
    s.feedKey('Ctrl-U');
    feedString(s, 'editor');
  },

  // ─── Confirm prompt ───

  tmux_confirm_kill(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('x');
  },

  // ─── Copy mode ───

  tmux_copy_mode(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('[');
  },

  tmux_copy_mode_moved(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('[');
    s.feedKey('l');
    s.feedKey('l');
    s.feedKey('j');
  },

  // ─── Pane close ───

  tmux_close_pane(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
    s.feedKey('Ctrl-B');
    s.feedKey('x');
    s.feedKey('y');
  },

  // ─── Window switching ───

  tmux_switch_window(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    feedString(s, 'echo WIN0');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('c');
    feedString(s, 'echo WIN1');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('0');
  },

  // ─── Detach and reattach ───

  tmux_detach_shell(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('d');
  },

  tmux_reattach(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    feedString(s, 'echo PERSISTENT');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('d');
    feedString(s, 'tmux attach');
    s.feedKey('Enter');
  },

  // ─── Overlays ───

  tmux_help(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('?');
  },

  tmux_pane_numbers(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
    s.feedKey('Ctrl-B');
    s.feedKey('q');
  },

  // ─── Break pane ───

  tmux_break_pane(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    feedString(s, 'echo ORIGINAL');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
    feedString(s, 'echo BROKEN_OUT');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('!');
  },

  // ─── Zoom ───

  tmux_zoom_pane(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
    feedString(s, 'echo ZOOMED');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('z');
  },

  tmux_zoom_unzoom(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
    s.feedKey('Ctrl-B');
    s.feedKey('z');
    s.feedKey('Ctrl-B');
    s.feedKey('z');
  },

  // ─── Border colors (active vs inactive) ───

  tmux_vsplit_active_right(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
  },

  tmux_vsplit_active_left(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
    s.feedKey('Ctrl-B');
    s.feedKey('ArrowLeft');
  },

  // ─── Window list ───

  tmux_window_list(s) {
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('c');
    s.feedKey('Ctrl-B');
    s.feedKey('c');
    s.feedKey('Ctrl-B');
    s.feedKey('w');
  },
};

// ── Special-dimension scenarios ──
// These need a non-default session size (the scenario dict can't express that)
const specialDimensions = {
  tmux_four_panes: { rows: 24, cols: 80 },
};

function replayScenario(name) {
  const dims = specialDimensions[name];
  if (dims) {
    // Custom dimensions — build scenario inline
    const s = newSession(dims);
    feedString(s, 'tmux');
    s.feedKey('Enter');
    s.feedKey('Ctrl-B');
    s.feedKey('%');
    s.feedKey('Ctrl-B');
    s.feedKey('"');
    s.feedKey('Ctrl-B');
    s.feedKey('ArrowLeft');
    s.feedKey('Ctrl-B');
    s.feedKey('"');
    return s;
  }

  const scenarioFn = scenarios[name];
  if (!scenarioFn) return null;

  const s = newSession();
  scenarioFn(s);
  return s;
}

// ── Run tests ──
let passed = 0;
let totalFailed = 0;
const failures = [];

console.log('============================================================');
console.log('Tmux Screen Tests');
console.log('============================================================');

for (const [name, gt] of Object.entries(groundTruth)) {
  if (filterCase && name !== filterCase) continue;

  const s = replayScenario(name);
  if (!s) {
    console.log(`  SKIP  ${name} (no replay scenario defined)`);
    continue;
  }

  const frame = s.renderFrame();

  // Freeze status bar time in the replayed frame (same as generator)
  freezeStatusBarTime(frame);

  // Compare text lines
  const gtTextLines = gt.textLines;
  const simTextLines = frame.lines.map(l => l.text);
  const textDiffs = diffLines(gtTextLines, simTextLines);

  // Compare cursor position
  const cursorMatch = (
    gt.cursor.row === frame.cursor.row &&
    gt.cursor.col === frame.cursor.col
  );

  // Compare cursor shape (if ground truth includes it)
  const gtShape = gt.cursor.shape || undefined;
  const simShape = frame.cursor.shape || undefined;
  const shapeMatch = (gtShape === simShape);

  // Compare colors
  let colorDiffs = [];
  if (!skipColors && gt.frame && gt.frame.lines) {
    colorDiffs = diffRuns(gt.frame, frame);
  }

  if (textDiffs.length === 0 && cursorMatch && shapeMatch && colorDiffs.length === 0) {
    passed++;
  } else {
    console.log(`  FAIL  ${name}`);
    if (!cursorMatch) {
      console.log(`        cursor: expected (${gt.cursor.row},${gt.cursor.col}) got (${frame.cursor.row},${frame.cursor.col})`);
    }
    if (!shapeMatch) {
      console.log(`        cursor shape: expected ${gtShape} got ${simShape}`);
    }
    if (textDiffs.length > 0) {
      for (const d of textDiffs.slice(0, 3)) {
        console.log(`        row ${d.row}: expected ${d.expected}`);
        console.log(`                  actual   ${d.actual}`);
      }
    }
    if (colorDiffs.length > 0) {
      console.log(`        color mismatches:`);
      for (const d of colorDiffs.slice(0, 3)) {
        console.log(`          row ${d.row}: gt   ${d.expected}`);
        console.log(`          ${String(d.row).replace(/./g, ' ')}       sim  ${d.actual}`);
      }
    }
    failures.push(name);
    totalFailed++;
  }
}

// ── Summary ──
const total = passed + totalFailed;
console.log(`\n  Tmux Screen: ${passed}/${total} passed` +
  (totalFailed > 0 ? ` ❌ ${totalFailed} failed` : ' ✅'));

console.log('============================================================');
console.log(`TOTAL: ${passed} passed, ${totalFailed} failed`);
console.log('============================================================');

if (failures.length > 0) {
  console.log('\nFailed cases:');
  for (const f of failures) {
    console.log(`  ${f}`);
  }
  process.exit(1);
}
