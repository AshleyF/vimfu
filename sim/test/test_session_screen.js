/**
 * VimFu Simulator – Session Screen Tests
 *
 * Compares rendered screen frames from SessionManager scenarios against
 * ground truth snapshots, ensuring pixel-perfect screen output for the
 * full shell↔vim integration.
 *
 * This mirrors the compare_test_v2.js approach used for the vim engine:
 *   1. Replay each scenario through SessionManager
 *   2. Render a frame
 *   3. Compare text, cursor, and color runs against ground truth
 *
 * Ground truth is generated by: node test/gen_session_ground_truth.js
 *
 * Usage:
 *   node test/test_session_screen.js                  # run all cases
 *   node test/test_session_screen.js --case shell_initial_prompt
 *   node test/test_session_screen.js --no-color       # skip color checks
 */

import { readFileSync, existsSync } from 'fs';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';
import { SessionManager } from '../src/session.js';

const __dirname = dirname(fileURLToPath(import.meta.url));
const GT_PATH = resolve(__dirname, 'session_ground_truth.json');

// ── Parse args ──
const args = process.argv.slice(2);
let filterCase = null;
let skipColors = false;
for (let i = 0; i < args.length; i++) {
  if (args[i] === '--case' && args[i + 1]) filterCase = args[++i];
  else if (args[i] === '--no-color') skipColors = true;
}

// ── Load ground truth ──
if (!existsSync(GT_PATH)) {
  console.error('Ground truth not found! Run: node test/gen_session_ground_truth.js');
  process.exit(1);
}
const groundTruth = JSON.parse(readFileSync(GT_PATH, 'utf-8'));

// ── Helpers ──
const ROWS = 20;
const COLS = 40;

function newSession(opts = {}) {
  return new SessionManager({
    rows: ROWS, cols: COLS, persist: false, ...opts,
  });
}

function feedString(s, str) {
  for (const ch of str) s.feedKey(ch);
}

function diffLines(expected, actual) {
  const diffs = [];
  const maxLen = Math.max(expected.length, actual.length);
  for (let i = 0; i < maxLen; i++) {
    const e = expected[i] ?? '<missing>';
    const a = actual[i] ?? '<missing>';
    if (e !== a) {
      diffs.push({ row: i, expected: JSON.stringify(e), actual: JSON.stringify(a) });
    }
  }
  return diffs;
}

function diffRuns(gtFrame, simFrame) {
  const diffs = [];
  const numRows = Math.min(gtFrame.lines.length, simFrame.lines.length);
  for (let i = 0; i < numRows; i++) {
    const gtRuns = gtFrame.lines[i].runs;
    const simRuns = simFrame.lines[i].runs;
    const gtStr = gtRuns.map(r => `${r.n}:${r.fg}/${r.bg}`).join(' ');
    const simStr = simRuns.map(r => `${r.n}:${r.fg}/${r.bg}`).join(' ');
    if (gtStr !== simStr) {
      diffs.push({ row: i, expected: gtStr, actual: simStr });
    }
  }
  return diffs;
}

// ── Scenario replay definitions ──
// Each scenario returns the SessionManager state at the point to snapshot.
const scenarios = {
  shell_initial_prompt(s) {
    // Fresh shell – no input
  },

  shell_ls_with_files(s) {
    s.fs.write('hello.txt', 'hello');
    s.fs.write('world.txt', 'world');
    feedString(s, 'ls');
    s.feedKey('Enter');
  },

  shell_cat_file(s) {
    s.fs.write('demo.txt', 'line one\nline two\nline three');
    feedString(s, 'cat demo.txt');
    s.feedKey('Enter');
  },

  shell_unknown_command(s) {
    feedString(s, 'badcmd');
    s.feedKey('Enter');
  },

  shell_echo_redirect(s) {
    feedString(s, 'echo hello > test.txt');
    s.feedKey('Enter');
  },

  shell_clear(s) {
    feedString(s, 'echo noise');
    s.feedKey('Enter');
    feedString(s, 'clear');
    s.feedKey('Enter');
  },

  vim_launch_new_file(s) {
    feedString(s, 'vim test.txt');
    s.feedKey('Enter');
  },

  vim_launch_existing_file(s) {
    s.fs.write('existing.txt', 'Hello from VFS\nSecond line');
    feedString(s, 'vim existing.txt');
    s.feedKey('Enter');
  },

  vim_write_new_file(s) {
    feedString(s, 'vim test.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'Hello VimFu');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'w');
    s.feedKey('Enter');
  },

  vim_write_multiline(s) {
    feedString(s, 'vim multi.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'Line 1');
    s.feedKey('Enter');
    feedString(s, 'Line 2');
    s.feedKey('Enter');
    feedString(s, 'Line 3');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'w');
    s.feedKey('Enter');
  },

  vim_quit_dirty_e37(s) {
    feedString(s, 'vim dirty.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'unsaved data');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'q');
    s.feedKey('Enter');
  },

  vim_quit_dirty_e37_dismiss(s) {
    feedString(s, 'vim dirty.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'unsaved data');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'q');
    s.feedKey('Enter');
    s.feedKey('Enter');  // dismiss
  },

  vim_wq_back_to_shell(s) {
    feedString(s, 'vim wq.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'saved');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'wq');
    s.feedKey('Enter');
  },

  vim_q_clean_back_to_shell(s) {
    feedString(s, 'vim test.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'q');
    s.feedKey('Enter');
  },

  vim_q_bang_back_to_shell(s) {
    feedString(s, 'vim dirty.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'will discard');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'q!');
    s.feedKey('Enter');
  },

  vim_ZZ_saves_and_quits(s) {
    feedString(s, 'vim zz.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'ZZ content');
    s.feedKey('Escape');
    s.feedKey('Z');
    s.feedKey('Z');
  },

  vim_ZQ_quits_without_saving(s) {
    feedString(s, 'vim zq.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'discard me');
    s.feedKey('Escape');
    s.feedKey('Z');
    s.feedKey('Q');
  },

  vim_edit_different_file(s) {
    s.fs.write('other.txt', 'Other file content');
    feedString(s, 'vim first.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'e other.txt');
    s.feedKey('Enter');
  },

  roundtrip_create_reopen(s) {
    feedString(s, 'vim rt.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'persistent data');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'wq');
    s.feedKey('Enter');
    feedString(s, 'vim rt.txt');
    s.feedKey('Enter');
  },

  shell_ls_after_vim_write(s) {
    feedString(s, 'vim newfile.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'content');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'wq');
    s.feedKey('Enter');
    feedString(s, 'ls');
    s.feedKey('Enter');
  },

  vim_shell_escape_ls(s) {
    s.fs.write('afile.txt', 'data');
    feedString(s, 'vim test');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, '!ls');
    s.feedKey('Enter');
  },

  vim_shell_escape_ls_dismiss(s) {
    s.fs.write('afile.txt', 'data');
    feedString(s, 'vim test');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, '!ls');
    s.feedKey('Enter');
    s.feedKey('Enter');  // dismiss
  },
};

// ── Run tests ──
let passed = 0;
let totalFailed = 0;
const failures = [];

console.log('============================================================');
console.log('Session Screen Tests');
console.log('============================================================');

for (const [name, gt] of Object.entries(groundTruth)) {
  if (filterCase && name !== filterCase) continue;

  const scenarioFn = scenarios[name];
  if (!scenarioFn) {
    console.log(`  SKIP  ${name} (no replay scenario defined)`);
    continue;
  }

  // Replay scenario
  const s = newSession();
  scenarioFn(s);
  const frame = s.renderFrame();

  // Compare text lines
  const gtTextLines = gt.textLines;
  const simTextLines = frame.lines.map(l => l.text);
  const textDiffs = diffLines(gtTextLines, simTextLines);

  // Compare cursor
  const cursorMatch = (
    gt.cursor.row === frame.cursor.row &&
    gt.cursor.col === frame.cursor.col
  );

  // Compare colors
  let colorDiffs = [];
  if (!skipColors && gt.frame && gt.frame.lines) {
    colorDiffs = diffRuns(gt.frame, frame);
  }

  if (textDiffs.length === 0 && cursorMatch && colorDiffs.length === 0) {
    passed++;
  } else {
    console.log(`  FAIL  ${name}`);
    if (!cursorMatch) {
      console.log(`        cursor: expected (${gt.cursor.row},${gt.cursor.col}) got (${frame.cursor.row},${frame.cursor.col})`);
    }
    if (textDiffs.length > 0) {
      for (const d of textDiffs.slice(0, 3)) {
        console.log(`        row ${d.row}: expected ${d.expected}`);
        console.log(`                  actual   ${d.actual}`);
      }
    }
    if (colorDiffs.length > 0) {
      console.log(`        color mismatches:`);
      for (const d of colorDiffs.slice(0, 3)) {
        console.log(`          row ${d.row}: gt   ${d.expected}`);
        console.log(`          ${String(d.row).replace(/./g, ' ')}       sim  ${d.actual}`);
      }
    }
    failures.push(name);
    totalFailed++;
  }
}

// ── Summary ──
const total = passed + totalFailed;
console.log(`\n  Session Screen: ${passed}/${total} passed` +
  (totalFailed > 0 ? ` ❌ ${totalFailed} failed` : ' ✅'));

console.log('============================================================');
console.log(`TOTAL: ${passed} passed, ${totalFailed} failed`);
console.log('============================================================');

if (failures.length > 0) {
  console.log('\nFailed cases:');
  for (const f of failures) {
    console.log(`  ${f}`);
  }
  process.exit(1);
}
