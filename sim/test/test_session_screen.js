/**
 * VimFu Simulator – Session Screen Tests
 *
 * Compares rendered screen frames from SessionManager scenarios against
 * ground truth snapshots, ensuring pixel-perfect screen output for the
 * full shell↔vim integration.
 *
 * This mirrors the compare_test_v2.js approach used for the vim engine:
 *   1. Replay each scenario through SessionManager
 *   2. Render a frame
 *   3. Compare text, cursor, and color runs against ground truth
 *
 * Ground truth is generated by: node test/gen_session_ground_truth.js
 *
 * Usage:
 *   node test/test_session_screen.js                  # run all cases
 *   node test/test_session_screen.js --case shell_initial_prompt
 *   node test/test_session_screen.js --no-color       # skip color checks
 */

import { readFileSync, existsSync } from 'fs';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';
import { SessionManager } from '../src/session.js';

const __dirname = dirname(fileURLToPath(import.meta.url));
const GT_PATH = resolve(__dirname, 'session_ground_truth.json');

// ── Parse args ──
const args = process.argv.slice(2);
let filterCase = null;
let skipColors = false;
for (let i = 0; i < args.length; i++) {
  if (args[i] === '--case' && args[i + 1]) filterCase = args[++i];
  else if (args[i] === '--no-color') skipColors = true;
}

// ── Load ground truth ──
if (!existsSync(GT_PATH)) {
  console.error('Ground truth not found! Run: node test/gen_session_ground_truth.js');
  process.exit(1);
}
const groundTruth = JSON.parse(readFileSync(GT_PATH, 'utf-8'));

// ── Helpers ──
const ROWS = 20;
const COLS = 40;

function newSession(opts = {}) {
  return new SessionManager({
    rows: ROWS, cols: COLS, persist: false, ...opts,
  });
}

function feedString(s, str) {
  for (const ch of str) s.feedKey(ch);
}

function diffLines(expected, actual) {
  const diffs = [];
  const maxLen = Math.max(expected.length, actual.length);
  for (let i = 0; i < maxLen; i++) {
    const e = expected[i] ?? '<missing>';
    const a = actual[i] ?? '<missing>';
    if (e !== a) {
      diffs.push({ row: i, expected: JSON.stringify(e), actual: JSON.stringify(a) });
    }
  }
  return diffs;
}

function diffRuns(gtFrame, simFrame) {
  const diffs = [];
  const numRows = Math.min(gtFrame.lines.length, simFrame.lines.length);
  for (let i = 0; i < numRows; i++) {
    const gtRuns = gtFrame.lines[i].runs;
    const simRuns = simFrame.lines[i].runs;
    const gtStr = gtRuns.map(r => `${r.n}:${r.fg}/${r.bg}`).join(' ');
    const simStr = simRuns.map(r => `${r.n}:${r.fg}/${r.bg}`).join(' ');
    if (gtStr !== simStr) {
      diffs.push({ row: i, expected: gtStr, actual: simStr });
    }
  }
  return diffs;
}

// ── Scenario replay definitions ──
// Each scenario returns the SessionManager state at the point to snapshot.
const scenarios = {
  shell_initial_prompt(s) {
    // Fresh shell – no input
  },

  shell_ls_with_files(s) {
    s.fs.write('hello.txt', 'hello');
    s.fs.write('world.txt', 'world');
    feedString(s, 'ls');
    s.feedKey('Enter');
  },

  shell_cat_file(s) {
    s.fs.write('demo.txt', 'line one\nline two\nline three');
    feedString(s, 'cat demo.txt');
    s.feedKey('Enter');
  },

  shell_unknown_command(s) {
    feedString(s, 'badcmd');
    s.feedKey('Enter');
  },

  shell_echo_redirect(s) {
    feedString(s, 'echo hello > test.txt');
    s.feedKey('Enter');
  },

  shell_clear(s) {
    feedString(s, 'echo noise');
    s.feedKey('Enter');
    feedString(s, 'clear');
    s.feedKey('Enter');
  },

  vim_launch_new_file(s) {
    feedString(s, 'vim test.txt');
    s.feedKey('Enter');
  },

  vim_launch_existing_file(s) {
    s.fs.write('existing.txt', 'Hello from VFS\nSecond line');
    feedString(s, 'vim existing.txt');
    s.feedKey('Enter');
  },

  vim_write_new_file(s) {
    feedString(s, 'vim test.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'Hello VimFu');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'w');
    s.feedKey('Enter');
  },

  vim_write_multiline(s) {
    feedString(s, 'vim multi.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'Line 1');
    s.feedKey('Enter');
    feedString(s, 'Line 2');
    s.feedKey('Enter');
    feedString(s, 'Line 3');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'w');
    s.feedKey('Enter');
  },

  vim_quit_dirty_e37(s) {
    feedString(s, 'vim dirty.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'unsaved data');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'q');
    s.feedKey('Enter');
  },

  vim_quit_dirty_e37_dismiss(s) {
    feedString(s, 'vim dirty.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'unsaved data');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'q');
    s.feedKey('Enter');
    s.feedKey('Enter');  // dismiss
  },

  vim_wq_back_to_shell(s) {
    feedString(s, 'vim wq.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'saved');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'wq');
    s.feedKey('Enter');
  },

  vim_q_clean_back_to_shell(s) {
    feedString(s, 'vim test.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'q');
    s.feedKey('Enter');
  },

  vim_q_bang_back_to_shell(s) {
    feedString(s, 'vim dirty.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'will discard');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'q!');
    s.feedKey('Enter');
  },

  vim_ZZ_saves_and_quits(s) {
    feedString(s, 'vim zz.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'ZZ content');
    s.feedKey('Escape');
    s.feedKey('Z');
    s.feedKey('Z');
  },

  vim_ZQ_quits_without_saving(s) {
    feedString(s, 'vim zq.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'discard me');
    s.feedKey('Escape');
    s.feedKey('Z');
    s.feedKey('Q');
  },

  vim_edit_different_file(s) {
    s.fs.write('other.txt', 'Other file content');
    feedString(s, 'vim first.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'e other.txt');
    s.feedKey('Enter');
  },

  roundtrip_create_reopen(s) {
    feedString(s, 'vim rt.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'persistent data');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'wq');
    s.feedKey('Enter');
    feedString(s, 'vim rt.txt');
    s.feedKey('Enter');
  },

  shell_ls_after_vim_write(s) {
    feedString(s, 'vim newfile.txt');
    s.feedKey('Enter');
    s.feedKey('i');
    feedString(s, 'content');
    s.feedKey('Escape');
    s.feedKey(':');
    feedString(s, 'wq');
    s.feedKey('Enter');
    feedString(s, 'ls');
    s.feedKey('Enter');
  },

  vim_shell_escape_ls(s) {
    s.fs.write('afile.txt', 'data');
    feedString(s, 'vim test');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, '!ls');
    s.feedKey('Enter');
  },

  vim_shell_escape_ls_dismiss(s) {
    s.fs.write('afile.txt', 'data');
    feedString(s, 'vim test');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, '!ls');
    s.feedKey('Enter');
    s.feedKey('Enter');  // dismiss
  },

  // ── Shell vi-mode ──

  shell_set_o_vi(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
  },

  shell_vi_type_and_escape(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello world');
    s.feedKey('Escape');
  },

  shell_vi_motion_0_dollar(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello world foo');
    s.feedKey('Escape');
    s.feedKey('0');
  },

  shell_vi_motion_w(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello world foo');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('w');
  },

  shell_vi_motion_b(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello world foo');
    s.feedKey('Escape');
    s.feedKey('b');
  },

  shell_vi_x_delete(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abc');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('x');
  },

  shell_vi_dw(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello world foo');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('d');
    s.feedKey('w');
  },

  shell_vi_cw(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello world');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('c');
    s.feedKey('w');
    feedString(s, 'Hi');
    s.feedKey('Escape');
  },

  shell_vi_dd(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'delete me');
    s.feedKey('Escape');
    s.feedKey('d');
    s.feedKey('d');
  },

  shell_vi_f_motion(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'find the char');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('f');
    s.feedKey('t');
  },

  shell_vi_f_semicolon_repeat(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'find the things there');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('f');
    s.feedKey('t');
    s.feedKey(';');
  },

  shell_vi_r_replace(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abc');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('r');
    s.feedKey('X');
  },

  shell_vi_p_paste(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abc');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('x');
    s.feedKey('p');
  },

  shell_vi_I_insert_start(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'world');
    s.feedKey('Escape');
    s.feedKey('I');
    feedString(s, 'hello ');
    s.feedKey('Escape');
  },

  shell_vi_A_append_end(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello');
    s.feedKey('Escape');
    s.feedKey('A');
    feedString(s, ' world');
    s.feedKey('Escape');
  },

  shell_vi_tilde_swap_case(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('~');
    s.feedKey('~');
    s.feedKey('~');
  },

  shell_vi_C_change_to_end(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello world');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('w');
    s.feedKey('C');
    feedString(s, 'vim');
    s.feedKey('Escape');
  },

  shell_vi_D_delete_to_end(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello world foo');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('w');
    s.feedKey('D');
  },

  shell_vi_cursor_shape_normal(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'test');
    s.feedKey('Escape');
  },

  shell_vi_cursor_shape_insert(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'test');
    s.feedKey('Escape');
    s.feedKey('i');
  },

  shell_vi_set_o_emacs(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'set -o emacs');
    s.feedKey('Enter');
    feedString(s, 'test');
  },

  shell_vi_enter_executes_from_normal(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'echo hello');
    s.feedKey('Escape');
    s.feedKey('Enter');
  },

  shell_vi_df_motion(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abcdef');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('d');
    s.feedKey('f');
    s.feedKey('d');
  },

  shell_vi_s_substitute(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'xyz');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('s');
    feedString(s, 'AB');
    s.feedKey('Escape');
  },

  // ── numeric counts ──

  shell_vi_2w_count(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello world foo');
    s.feedKey('Escape');
    s.feedKey('0');
    feedString(s, '2');
    s.feedKey('w');
  },

  shell_vi_3x_count(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abcdef');
    s.feedKey('Escape');
    s.feedKey('0');
    feedString(s, '3');
    s.feedKey('x');
  },

  shell_vi_2dw_count(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'aaa bbb ccc ddd');
    s.feedKey('Escape');
    s.feedKey('0');
    feedString(s, '2');
    s.feedKey('d');
    s.feedKey('w');
  },

  shell_vi_3l_count(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abcdef');
    s.feedKey('Escape');
    s.feedKey('0');
    feedString(s, '3');
    s.feedKey('l');
  },

  shell_vi_2p_count(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abc');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('x');
    feedString(s, '2');
    s.feedKey('p');
  },

  // ── undo ──

  shell_vi_undo(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('x');
    s.feedKey('u');
  },

  shell_vi_undo_multiple(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abc');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('x');
    s.feedKey('x');
    s.feedKey('u');
    s.feedKey('u');
  },

  // ── dot repeat ──

  shell_vi_dot_repeat_cw(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'aaa bbb ccc');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('c');
    s.feedKey('w');
    feedString(s, 'XXX');
    s.feedKey('Escape');
    s.feedKey('w');
    s.feedKey('.');
  },

  shell_vi_dot_repeat_x(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abcd');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('x');
    s.feedKey('.');
    s.feedKey('.');
  },

  // ── t/T motions ──

  shell_vi_t_motion(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello world');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('t');
    s.feedKey('o');
  },

  shell_vi_T_motion(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello world');
    s.feedKey('Escape');
    s.feedKey('T');
    s.feedKey(' ');
  },

  shell_vi_dt_motion(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abcdef');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('d');
    s.feedKey('t');
    s.feedKey('d');
  },

  shell_vi_ct_motion(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abcdef');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('c');
    s.feedKey('t');
    s.feedKey('d');
    feedString(s, 'XY');
    s.feedKey('Escape');
  },

  // ── R replace mode ──

  shell_vi_R_replace_mode(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abcdef');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('R');
    feedString(s, 'XY');
    s.feedKey('Escape');
  },

  shell_vi_R_backspace_restores(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abcdef');
    s.feedKey('Escape');
    s.feedKey('0');
    s.feedKey('R');
    feedString(s, 'XY');
    s.feedKey('Backspace');
    s.feedKey('Escape');
  },

  // ── G history ──

  shell_vi_G_oldest_history(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'echo first');
    s.feedKey('Enter');
    feedString(s, 'echo second');
    s.feedKey('Enter');
    feedString(s, 'echo third');
    s.feedKey('Enter');
    s.feedKey('Escape');
    s.feedKey('G');
  },

  // ── # comment ──

  shell_vi_hash_comment(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'echo hello');
    s.feedKey('Escape');
    s.feedKey('#');
  },

  // ── history search ──

  shell_vi_search_history(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'echo alpha');
    s.feedKey('Enter');
    feedString(s, 'echo beta');
    s.feedKey('Enter');
    feedString(s, 'echo gamma');
    s.feedKey('Enter');
    s.feedKey('Escape');
    s.feedKey('/');
    feedString(s, 'alpha');
    s.feedKey('Enter');
  },

  // ── count with r and ~ ──

  shell_vi_r_count(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'abcdef');
    s.feedKey('Escape');
    s.feedKey('0');
    feedString(s, '3');
    s.feedKey('r');
    s.feedKey('X');
  },

  shell_vi_tilde_count(s) {
    feedString(s, 'set -o vi');
    s.feedKey('Enter');
    feedString(s, 'hello');
    s.feedKey('Escape');
    s.feedKey('0');
    feedString(s, '3');
    s.feedKey('~');
  },

  // ── New shell commands ──

  shell_wc(s) {
    s.fs.write('data.txt', 'hello world\nfoo bar baz\nend');
    feedString(s, 'wc data.txt');
    s.feedKey('Enter');
  },

  shell_wc_l_flag(s) {
    s.fs.write('data.txt', 'line1\nline2\nline3');
    feedString(s, 'wc -l data.txt');
    s.feedKey('Enter');
  },

  shell_head(s) {
    const lines = [];
    for (let i = 1; i <= 15; i++) lines.push(`line ${i}`);
    s.fs.write('big.txt', lines.join('\n'));
    feedString(s, 'head big.txt');
    s.feedKey('Enter');
  },

  shell_head_n3(s) {
    s.fs.write('data.txt', 'alpha\nbeta\ngamma\ndelta');
    feedString(s, 'head -n 3 data.txt');
    s.feedKey('Enter');
  },

  shell_tail(s) {
    const lines = [];
    for (let i = 1; i <= 15; i++) lines.push(`line ${i}`);
    s.fs.write('big.txt', lines.join('\n'));
    feedString(s, 'tail -n 5 big.txt');
    s.feedKey('Enter');
  },

  shell_grep(s) {
    s.fs.write('poem.txt', 'roses are red\nviolets are blue\nsugar is sweet\nand so are you');
    feedString(s, 'grep are poem.txt');
    s.feedKey('Enter');
  },

  shell_grep_n_flag(s) {
    s.fs.write('poem.txt', 'roses are red\nviolets are blue\nsugar is sweet\nand so are you');
    feedString(s, 'grep -n are poem.txt');
    s.feedKey('Enter');
  },

  shell_grep_c_flag(s) {
    s.fs.write('poem.txt', 'roses are red\nviolets are blue\nsugar is sweet\nand so are you');
    feedString(s, 'grep -c are poem.txt');
    s.feedKey('Enter');
  },

  shell_grep_i_flag(s) {
    s.fs.write('names.txt', 'Alice\nalice\nBob\nALICE');
    feedString(s, 'grep -i alice names.txt');
    s.feedKey('Enter');
  },

  shell_cp(s) {
    s.fs.write('src.txt', 'original content');
    feedString(s, 'cp src.txt dst.txt');
    s.feedKey('Enter');
    feedString(s, 'cat dst.txt');
    s.feedKey('Enter');
  },

  shell_mv(s) {
    s.fs.write('old.txt', 'moved content');
    feedString(s, 'mv old.txt new.txt');
    s.feedKey('Enter');
    feedString(s, 'cat new.txt');
    s.feedKey('Enter');
  },

  shell_history(s) {
    feedString(s, 'echo one');
    s.feedKey('Enter');
    feedString(s, 'echo two');
    s.feedKey('Enter');
    feedString(s, 'history');
    s.feedKey('Enter');
  },

  shell_whoami(s) {
    feedString(s, 'whoami');
    s.feedKey('Enter');
  },

  shell_which(s) {
    feedString(s, 'which cat ls');
    s.feedKey('Enter');
  },

  shell_which_unknown(s) {
    feedString(s, 'which fakecmd');
    s.feedKey('Enter');
  },

  shell_echo_append_redirect(s) {
    feedString(s, 'echo hello > test.txt');
    s.feedKey('Enter');
    feedString(s, 'echo world >> test.txt');
    s.feedKey('Enter');
    feedString(s, 'cat test.txt');
    s.feedKey('Enter');
  },

  shell_exit(s) {
    feedString(s, 'exit');
    s.feedKey('Enter');
    // After exit, further input should be ignored
    feedString(s, 'echo should not appear');
    s.feedKey('Enter');
  },

  shell_tab_complete_command(s) {
    feedString(s, 'hel');
    s.feedKey('Tab');
    // Should complete to "help "
  },

  shell_tab_complete_file(s) {
    s.fs.write('readme.txt', 'hello');
    feedString(s, 'cat rea');
    s.feedKey('Tab');
    // Should complete to "cat readme.txt"
  },

  // ── :! commands from vim ──

  vim_bang_wc(s) {
    s.fs.write('data.txt', 'one two three\nfour five');
    feedString(s, 'vim data.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, '!wc data.txt');
    s.feedKey('Enter');
  },

  vim_bang_grep(s) {
    s.fs.write('data.txt', 'apple\nbanana\napricot');
    feedString(s, 'vim data.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, '!grep ap data.txt');
    s.feedKey('Enter');
  },

  vim_bang_cp(s) {
    s.fs.write('src.txt', 'content');
    feedString(s, 'vim src.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, '!cp src.txt copy.txt');
    s.feedKey('Enter');
  },

  // ── :r (read) ──

  vim_read_file(s) {
    s.fs.write('main.txt', 'Line one\nLine two\nLine three');
    s.fs.write('extra.txt', 'Alpha\nBravo');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'r extra.txt');
    s.feedKey('Enter');
  },

  vim_read_file_line2(s) {
    s.fs.write('main.txt', 'Line one\nLine two\nLine three');
    s.fs.write('extra.txt', 'Alpha\nBravo');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey('j');
    s.feedKey(':');
    feedString(s, 'r extra.txt');
    s.feedKey('Enter');
  },

  vim_read_file_last_line(s) {
    s.fs.write('main.txt', 'Line one\nLine two\nLine three');
    s.fs.write('extra.txt', 'Alpha\nBravo\nCharlie');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey('G');
    s.feedKey(':');
    feedString(s, 'r extra.txt');
    s.feedKey('Enter');
  },

  vim_read_nonexistent(s) {
    s.fs.write('main.txt', 'Hello');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'r nosuchfile.txt');
    s.feedKey('Enter');
  },

  vim_read_no_filename(s) {
    s.fs.write('main.txt', 'Hello');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'r');
    s.feedKey('Enter');
  },

  // ── :r Tab completion ──

  vim_tab_r_no_partial(s) {
    s.fs.write('main.txt', 'Hello');
    s.fs.write('demo.py', 'def f(): pass');
    s.fs.write('demo.txt', 'some text');
    s.fs.write('notes.txt', 'my notes');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'r ');
    s.feedKey('Tab');
  },

  vim_tab_r_partial_d(s) {
    s.fs.write('main.txt', 'Hello');
    s.fs.write('demo.py', 'def f(): pass');
    s.fs.write('demo.txt', 'some text');
    s.fs.write('notes.txt', 'my notes');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'r d');
    s.feedKey('Tab');
  },

  vim_tab_r_partial_d_cycle(s) {
    s.fs.write('main.txt', 'Hello');
    s.fs.write('demo.py', 'def f(): pass');
    s.fs.write('demo.txt', 'some text');
    s.fs.write('notes.txt', 'my notes');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'r d');
    s.feedKey('Tab');
    s.feedKey('Tab');
  },

  vim_tab_r_unique_match(s) {
    s.fs.write('main.txt', 'Hello');
    s.fs.write('demo.py', 'def f(): pass');
    s.fs.write('demo.txt', 'some text');
    s.fs.write('notes.txt', 'my notes');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'r n');
    s.feedKey('Tab');
  },

  vim_tab_r_no_match(s) {
    s.fs.write('main.txt', 'Hello');
    s.fs.write('demo.py', 'def f(): pass');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'r z');
    s.feedKey('Tab');
  },

  vim_tab_e_partial(s) {
    s.fs.write('main.txt', 'Hello');
    s.fs.write('demo.py', 'def f(): pass');
    s.fs.write('demo.txt', 'some text');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'e d');
    s.feedKey('Tab');
  },

  vim_tab_w_no_partial(s) {
    s.fs.write('main.txt', 'Hello');
    s.fs.write('demo.py', 'def f(): pass');
    s.fs.write('notes.txt', 'my notes');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'w ');
    s.feedKey('Tab');
  },

  vim_tab_r_dot_partial(s) {
    s.fs.write('main.txt', 'Hello');
    s.fs.write('demo.py', 'def f(): pass');
    s.fs.write('demo.txt', 'some text');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'r demo.');
    s.feedKey('Tab');
  },

  vim_tab_r_dot_cycle(s) {
    s.fs.write('main.txt', 'Hello');
    s.fs.write('demo.py', 'def f(): pass');
    s.fs.write('demo.txt', 'some text');
    feedString(s, 'vim main.txt');
    s.feedKey('Enter');
    s.feedKey(':');
    feedString(s, 'r demo.');
    s.feedKey('Tab');
    s.feedKey('Tab');
  },
};

// ── Run tests ──
let passed = 0;
let totalFailed = 0;
const failures = [];

console.log('============================================================');
console.log('Session Screen Tests');
console.log('============================================================');

for (const [name, gt] of Object.entries(groundTruth)) {
  if (filterCase && name !== filterCase) continue;

  const scenarioFn = scenarios[name];
  if (!scenarioFn) {
    console.log(`  SKIP  ${name} (no replay scenario defined)`);
    continue;
  }

  // Replay scenario
  const s = newSession();
  scenarioFn(s);
  const frame = s.renderFrame();

  // Compare text lines
  const gtTextLines = gt.textLines;
  const simTextLines = frame.lines.map(l => l.text);
  const textDiffs = diffLines(gtTextLines, simTextLines);

  // Compare cursor position
  const cursorMatch = (
    gt.cursor.row === frame.cursor.row &&
    gt.cursor.col === frame.cursor.col
  );

  // Compare cursor shape (if ground truth includes it)
  const gtShape = gt.cursor.shape || undefined;
  const simShape = frame.cursor.shape || undefined;
  const shapeMatch = (gtShape === simShape);

  // Compare colors
  let colorDiffs = [];
  if (!skipColors && gt.frame && gt.frame.lines) {
    colorDiffs = diffRuns(gt.frame, frame);
  }

  if (textDiffs.length === 0 && cursorMatch && shapeMatch && colorDiffs.length === 0) {
    passed++;
  } else {
    console.log(`  FAIL  ${name}`);
    if (!cursorMatch) {
      console.log(`        cursor: expected (${gt.cursor.row},${gt.cursor.col}) got (${frame.cursor.row},${frame.cursor.col})`);
    }
    if (!shapeMatch) {
      console.log(`        cursor shape: expected ${gtShape} got ${simShape}`);
    }
    if (textDiffs.length > 0) {
      for (const d of textDiffs.slice(0, 3)) {
        console.log(`        row ${d.row}: expected ${d.expected}`);
        console.log(`                  actual   ${d.actual}`);
      }
    }
    if (colorDiffs.length > 0) {
      console.log(`        color mismatches:`);
      for (const d of colorDiffs.slice(0, 3)) {
        console.log(`          row ${d.row}: gt   ${d.expected}`);
        console.log(`          ${String(d.row).replace(/./g, ' ')}       sim  ${d.actual}`);
      }
    }
    failures.push(name);
    totalFailed++;
  }
}

// ── Summary ──
const total = passed + totalFailed;
console.log(`\n  Session Screen: ${passed}/${total} passed` +
  (totalFailed > 0 ? ` ❌ ${totalFailed} failed` : ' ✅'));

console.log('============================================================');
console.log(`TOTAL: ${passed} passed, ${totalFailed} failed`);
console.log('============================================================');

if (failures.length > 0) {
  console.log('\nFailed cases:');
  for (const f of failures) {
    console.log(`  ${f}`);
  }
  process.exit(1);
}
