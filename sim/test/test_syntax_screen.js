/**
 * VimFu Simulator – Syntax Highlighting Screen Tests
 *
 * Opens the sample Python file in the sim, scrolls through it, and
 * verifies that every visible line has the correct syntax-coloured runs.
 *
 * These are self-referential ground truth tests: the expected output is
 * generated by the sim itself (via gen_syntax_ground_truth.js) and saved
 * as syntax_ground_truth.json.  The tests replay the same scenarios and
 * compare frame-for-frame.
 *
 * Additionally, this file contains "structural" tests that directly
 * verify the token→colour integration works (e.g. "line 0 has green for
 * the docstring").  These don't need a ground truth file.
 *
 * Run: node test/test_syntax_screen.js
 */

import { VimEngine } from '../src/engine.js';
import { Screen } from '../src/screen.js';
import { SAMPLE_PYTHON } from '../src/samples.js';
import { SyntaxHighlighter } from '../src/highlight.js';
import { pythonGrammar } from '../src/langs/python.js';
import { readFileSync, existsSync } from 'fs';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const GT_PATH = resolve(__dirname, 'syntax_ground_truth.json');

const ROWS = 20;
const COLS = 40;

let passed = 0;
let failed = 0;

function assert(cond, msg) {
  if (cond) { passed++; }
  else { failed++; console.log(`  FAIL  ${msg}`); }
}

/** Create engine with sample Python loaded and syntax-ready. */
function makePyEngine() {
  const engine = new VimEngine({ rows: ROWS, cols: COLS });
  engine.filename = SAMPLE_PYTHON.filename;
  engine.loadFile(SAMPLE_PYTHON.content);
  return engine;
}

function feedKeys(engine, keys) {
  for (const ch of keys) {
    let key = ch;
    if (ch === '\x1b') key = 'Escape';
    else if (ch === '\r' || ch === '\n') key = 'Enter';
    engine.feedKey(key);
  }
}

/** Get the fg colour at a given screen column of a frame line. */
function fgAt(frameLine, col) {
  let pos = 0;
  for (const run of frameLine.runs) {
    if (col < pos + run.n) return run.fg;
    pos += run.n;
  }
  return null;
}

// ════════════════════════════════════════════════════════════════
// Structural: verify syntax colours appear in rendered frames
// ════════════════════════════════════════════════════════════════
console.log('============================================================');
console.log('Suite: Syntax Colour Integration');
console.log('============================================================');

{
  const engine = makePyEngine();
  const screen = new Screen(ROWS, COLS, 'nvim_default');
  const frame = screen.render(engine);

  const t = screen.theme;

  // Line 0: #!/usr/bin/env python3
  // The shebang line — #! starts a comment
  assert(fgAt(frame.lines[0], 0) === t.syntax.comment, 'colour: shebang is comment grey');

  // Line 1: """VimFu demo: Python syntax showcase."""
  // Triple-quoted string on one line
  assert(fgAt(frame.lines[1], 0) === t.syntax.string, 'colour: docstring is green');
  assert(fgAt(frame.lines[1], 3) === t.syntax.string, 'colour: docstring middle is green');

  // Line 3: import os
  // nvim default does NOT highlight import/from keywords
  assert(fgAt(frame.lines[3], 0) === t.normalFg, 'colour: import is normal (not highlighted)');
  // "os" is plain identifier → normalFg
  assert(fgAt(frame.lines[3], 7) === t.normalFg, 'colour: os is normal');

  // Line 5: from pathlib import Path
  assert(fgAt(frame.lines[5], 0) === t.normalFg, 'colour: from is normal (not highlighted)');
  // "import" at position 16
  assert(fgAt(frame.lines[5], 16) === t.normalFg, 'colour: from..import is normal');

  // Line 8: # Constants
  assert(fgAt(frame.lines[8], 0) === t.syntax.comment, 'colour: comment line is grey');

  // Line 9: MAX_SIZE = 100
  // nvim default does NOT highlight numbers
  assert(fgAt(frame.lines[9], 13) === t.normalFg, 'colour: integer is normal (not highlighted)');

  // Line 10: PI = 3.14159
  assert(fgAt(frame.lines[10], 5) === t.normalFg, 'colour: float is normal (not highlighted)');

  // Line 11: HEX = 0xFF
  assert(fgAt(frame.lines[11], 6) === t.normalFg, 'colour: hex is normal (not highlighted)');

  // GREETING = "Hello, VimFu!" (line 14)
  // String starts after = (at the ")
  const greetLine = frame.lines[14];
  const greetText = greetLine.text;
  const qStart = greetText.indexOf('"');
  assert(qStart >= 0 && fgAt(greetLine, qStart) === t.syntax.string, 'colour: string literal is green');
}

// ════════════════════════════════════════════════════════════════
// Structural: verify keywords, decorators, constants
// ════════════════════════════════════════════════════════════════
console.log('============================================================');
console.log('Suite: Syntax Keywords & Decorators');
console.log('============================================================');

{
  const engine = makePyEngine();
  const screen = new Screen(ROWS, COLS, 'nvim_default');

  // Scroll to @property line (line 23)
  const srcLines = SAMPLE_PYTHON.content.split('\n');
  const decIdx = srcLines.findIndex(l => l.trimStart().startsWith('@'));
  engine.scrollTop = decIdx;
  const frame = screen.render(engine);
  const t = screen.theme;

  // @ is NOT highlighted by nvim, only the name after it is
  const decLine = frame.lines[0];
  const decText = decLine.text.trimStart();
  if (decText.startsWith('@')) {
    const atCol = decLine.text.indexOf('@');
    assert(fgAt(decLine, atCol) === t.normalFg, 'colour: @ is normal (not highlighted)');
    assert(fgAt(decLine, atCol + 1) === t.syntax.decorator, 'colour: decorator name is cyan');
  }

  // def greet(name: str) -> str: (line after decorator)
  const defLine = frame.lines[1];
  const defPos = defLine.text.indexOf('def');
  if (defPos >= 0) {
    assert(fgAt(defLine, defPos) === t.normalFg, 'colour: def keyword is normal');
  }
}

{
  const engine = makePyEngine();
  const screen = new Screen(ROWS, COLS, 'nvim_default');
  const t = screen.theme;

  // EMPTY = None (line 19)
  const srcLines2 = SAMPLE_PYTHON.content.split('\n');
  const noneIdx = srcLines2.findIndex(l => l.startsWith('EMPTY'));
  engine.scrollTop = noneIdx;
  const frame = screen.render(engine);
  const noneLine = frame.lines[0];
  const nonePos = noneLine.text.indexOf('None');
  if (nonePos >= 0) {
    assert(fgAt(noneLine, nonePos) === t.syntax.constant, 'colour: None is cyan');
  }

  // IS_OK = True (next line after EMPTY)
  const trueLine = frame.lines[1];
  const truePos = trueLine.text.indexOf('True');
  if (truePos >= 0) {
    assert(fgAt(trueLine, truePos) === t.syntax.constant, 'colour: True is cyan');
  }

  // NOPE = False (two lines after EMPTY)
  const falseLine = frame.lines[2];
  const falsePos = falseLine.text.indexOf('False');
  if (falsePos >= 0) {
    assert(fgAt(falseLine, falsePos) === t.syntax.constant, 'colour: False is cyan');
  }
}

// ════════════════════════════════════════════════════════════════
// Structural: multi-line string spans
// ════════════════════════════════════════════════════════════════
console.log('============================================================');
console.log('Suite: Multi-line Strings');
console.log('============================================================');

{
  const engine = makePyEngine();
  const screen = new Screen(ROWS, COLS, 'nvim_default');
  const t = screen.theme;

  // MULTI = """triple\nquoted string"""
  // Find which buffer lines these are
  const lines = SAMPLE_PYTHON.content.split('\n');
  const multiStart = lines.findIndex(l => l.includes('MULTI = """'));
  assert(multiStart >= 0, 'multi: found MULTI line');

  if (multiStart >= 0) {
    engine.scrollTop = multiStart;
    const frame = screen.render(engine);

    // Line 0 in view: MULTI = """triple
    const l0 = frame.lines[0];
    const triplePos = l0.text.indexOf('"""');
    assert(triplePos >= 0 && fgAt(l0, triplePos) === t.syntax.string, 'multi: opening """ is green');
    // Text after """ should also be string
    assert(fgAt(l0, triplePos + 3) === t.syntax.string, 'multi: text after """ is green');

    // Line 1 in view: quoted string"""
    const l1 = frame.lines[1];
    assert(fgAt(l1, 0) === t.syntax.string, 'multi: continuation line is green');
  }
}

// ════════════════════════════════════════════════════════════════
// Structural: built-in functions get correct scope
// ════════════════════════════════════════════════════════════════
console.log('============================================================');
console.log('Suite: Built-in Functions');
console.log('============================================================');

{
  const engine = makePyEngine();
  const screen = new Screen(ROWS, COLS, 'nvim_default');
  const t = screen.theme;

  // Find "print(" in the file
  const lines = SAMPLE_PYTHON.content.split('\n');
  const printLine = lines.findIndex(l => l.trimStart().startsWith('print('));
  if (printLine >= 0) {
    engine.scrollTop = printLine;
    const frame = screen.render(engine);
    const pl = frame.lines[0];
    const printPos = pl.text.indexOf('print');
    // In nvim_default, builtin IS highlighted as 8cf8f7
    assert(printPos >= 0 && fgAt(pl, printPos) === t.syntax.builtin, 'builtin: print is cyan');
  }
}

// ════════════════════════════════════════════════════════════════
// Structural: class/def names highlighted
// ════════════════════════════════════════════════════════════════
console.log('============================================================');
console.log('Suite: Def/Class Names');
console.log('============================================================');

{
  const engine = makePyEngine();
  const screen = new Screen(ROWS, COLS, 'nvim_default');
  const t = screen.theme;

  // Find "class Animal:" line
  const lines = SAMPLE_PYTHON.content.split('\n');
  const classLine = lines.findIndex(l => l.startsWith('class Animal'));
  if (classLine >= 0) {
    engine.scrollTop = classLine;
    const frame = screen.render(engine);
    const cl = frame.lines[0];
    // "class" at col 0 → normal (nvim doesn't highlight keywords)
    assert(fgAt(cl, 0) === t.normalFg, 'defname: class keyword is normal');
    // "Animal" at col 6 → class.def → cyan in nvim
    assert(fgAt(cl, 6) === t.syntax['class.def'], 'defname: Animal class name is cyan');
  }
}

// ════════════════════════════════════════════════════════════════
// Monokai theme: verify different colours
// ════════════════════════════════════════════════════════════════
console.log('============================================================');
console.log('Suite: Monokai Theme');
console.log('============================================================');

{
  const engine = makePyEngine();
  const screen = new Screen(ROWS, COLS, 'monokai');
  const frame = screen.render(engine);
  const t = screen.theme;

  // Line 0: shebang → comment (olive)
  assert(fgAt(frame.lines[0], 0) === t.syntax.comment, 'monokai: comment is olive');

  // Line 1: docstring → string (yellow)
  assert(fgAt(frame.lines[1], 0) === t.syntax.string, 'monokai: string is yellow');

  // Line 3: import → keyword.import
  assert(fgAt(frame.lines[3], 0) === t.syntax['keyword.import'], 'monokai: import is highlighted');

  // Line 9: 100 → number (purple)
  assert(fgAt(frame.lines[9], 13) === t.syntax.number, 'monokai: number is purple');
}

// ════════════════════════════════════════════════════════════════
// No syntax on non-Python files
// ════════════════════════════════════════════════════════════════
console.log('============================================================');
console.log('Suite: No Syntax for .txt');
console.log('============================================================');

{
  const engine = new VimEngine({ rows: ROWS, cols: COLS });
  engine.filename = 'readme.txt';
  engine.loadFile('# Not a comment\nimport not_highlighted');
  const screen = new Screen(ROWS, COLS, 'nvim_default');
  const frame = screen.render(engine);

  // Everything should be normalFg
  const t = screen.theme;
  assert(fgAt(frame.lines[0], 0) === t.normalFg, 'txt: # not highlighted');
  assert(fgAt(frame.lines[1], 0) === t.normalFg, 'txt: import not highlighted');
}

{
  const engine = new VimEngine({ rows: ROWS, cols: COLS });
  // No filename set
  engine.loadFile('def hello(): pass');
  const screen = new Screen(ROWS, COLS, 'nvim_default');
  const frame = screen.render(engine);
  const t = screen.theme;
  assert(fgAt(frame.lines[0], 0) === t.normalFg, 'nofile: no highlighting without filename');
}

// ════════════════════════════════════════════════════════════════
// Ground truth comparison (if file exists)
// ════════════════════════════════════════════════════════════════
if (existsSync(GT_PATH)) {
  console.log('============================================================');
  console.log('Suite: Syntax Ground Truth');
  console.log('============================================================');

  const groundTruth = JSON.parse(readFileSync(GT_PATH, 'utf-8'));

  for (const [name, gt] of Object.entries(groundTruth)) {
    const engine = makePyEngine();
    const screen = new Screen(ROWS, COLS, 'nvim_default');

    // Apply scroll
    if (gt.scrollTop != null) {
      engine.scrollTop = gt.scrollTop;
    }
    // Apply keys
    if (gt.keys) {
      feedKeys(engine, gt.keys);
    }

    const frame = screen.render(engine);

    // Compare text lines
    let textMatch = true;
    for (let i = 0; i < gt.textLines.length; i++) {
      if (frame.lines[i].text !== gt.textLines[i]) {
        textMatch = false;
        break;
      }
    }

    // Compare colour runs
    let colorMatch = true;
    if (gt.frame && gt.frame.lines) {
      for (let i = 0; i < gt.frame.lines.length; i++) {
        const gtRuns = gt.frame.lines[i].runs.map(r => `${r.n}:${r.fg}/${r.bg}`).join(' ');
        const simRuns = frame.lines[i].runs.map(r => `${r.n}:${r.fg}/${r.bg}`).join(' ');
        if (gtRuns !== simRuns) {
          colorMatch = false;
          if (failed < 5) {
            console.log(`        row ${i}: gt  ${gtRuns}`);
            console.log(`                 sim ${simRuns}`);
          }
          break;
        }
      }
    }

    const cursorMatch = gt.cursor.row === frame.cursor.row && gt.cursor.col === frame.cursor.col;

    if (textMatch && colorMatch && cursorMatch) {
      passed++;
    } else {
      failed++;
      console.log(`  FAIL  ${name}`);
      if (!textMatch) console.log('        text mismatch');
      if (!colorMatch) console.log('        colour mismatch');
      if (!cursorMatch) console.log(`        cursor: expected (${gt.cursor.row},${gt.cursor.col}) got (${frame.cursor.row},${frame.cursor.col})`);
    }
  }
} else {
  console.log('============================================================');
  console.log('Suite: Syntax Ground Truth (SKIPPED - run gen_syntax_ground_truth.js first)');
  console.log('============================================================');
}

// ════════════════════════════════════════════════════════════════
// Summary
// ════════════════════════════════════════════════════════════════
console.log('============================================================');
console.log(`TOTAL: ${passed} passed, ${failed} failed`);
console.log('============================================================');
if (failed > 0) process.exit(1);
